
\documentclass{amsbook}

\usepackage{amssymb} % To pakiet z dodatkowymi symbolami matematycznymi
\usepackage{polski} \usepackage[cp1250]{inputenc} % Te pakiety umo¿liwiaj¹ sk³adanie pracy w jêzyku polskim
\usepackage{graphicx} % Ten pakiet umo¿liwia umieszczanie obrazków w tekœcie
\usepackage{fancyhdr,lipsum}
\usepackage{listings}
\usepackage{enumerate}
\usepackage{textcomp}
\usepackage{float}
\usepackage[svgnames]{xcolor}
\lstset{language=C,
	keywordstyle=\color{RoyalBlue},
	basicstyle=\scriptsize\ttfamily,
	commentstyle=\color{Green}\ttfamily,
	rulecolor=\color{black},
	upquote=true,
	numbers=left,
	numberstyle=\tiny\color{gray},
	stepnumber=1,
	numbersep=8pt,
	showstringspaces=false,
	breaklines=true,
	frameround=ftff,
	frame=single,
	belowcaptionskip=5em,
	belowskip=3em,
}
\pagestyle{fancy}
\fancyhead{}
\fancyfoot{}
\renewcommand{\headrulewidth}{0pt}
\fancyfoot[C]{\bfseries \thepage}

%\pagenumbering{arabic}
% Ten kawa³ek nag³ówka definiuje ró¿ne œrodowiska, których u¿ywaæ bêdziemy podczas pisania pracy. Jeœli
% potrzebne jest jakieœ inne, to mo¿na tu je dodaæ w analogiczny sposób jak poni¿ej.
% W tych œrodowiskach tekst pisany jest pochy³¹ czcionk¹:
\newtheorem{twierdzenie}{Twierdzenie}[chapter] % to jest g³owne œrodowisko, ono musi byæ zdefiniowane jako pierwsze
\newtheorem{lemat}[twierdzenie]{Lemat} % œrodowiska <Propozycja> proszê unikaæ, zamiast niego u¿ywamy <Lemat>
% W tych œrodowiskach tekst pisany jest prost¹ czcionk¹:
\theoremstyle{definition}
\newtheorem{definicja}[twierdzenie]{Definicja}
\newtheorem{obserwacja}[twierdzenie]{Obserwacja}
\newtheorem{uwaga}[twierdzenie]{Uwaga}
\newtheorem{przyklad}[twierdzenie]{Przyk³ad}


\begin{document}

% Strona tytu³owa %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{center}
\thispagestyle{empty} % Na stronie tytu³owej nie chcemy numeru strony
\includegraphics[width=1.5cm, height=1.5cm]{logo_uj.png} % Ta komenda umieszcza na stronie logo UJ

{\large \textbf{Uniwersytet Jagieloñski w Krakowie}

Wydzia³ Fizyki, Astronomii i Informatyki Stosowanej

} \vfill\vfill

{\huge \textbf{Jakub G¹cik}} \\
Nr. albumu 1113727
\vfill
{\huge \textbf{Opracowanie i implementacja algorytmu \medskip
sterowania ramieniem robota}}\bigskip\bigskip


{\large Praca licencjacka \\
	na kierunku Informatyka \vfill\vfill\vfill
	
	
	\begin{flushright}
		\large { Praca wykonana pod kierunkiem \\
			dr Grzegorza Zuzla \\
			z Zak³adu Doœwiadczalnej Fizyki Komputerowej
		}
	\end{flushright}   \vfill

Kraków 2017} \pagebreak % Tu oczywiœcie wstawiamy rok obrony
\end{center}

% Podziêkowania (ta strona jest opcjonalna) %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\thispagestyle{empty} % Na tej stronie te¿ nie chcemy numeru strony

\huge {Oœwiadczenie autora pracy} \\
\large {Œwiadom odpowiedzialnoœci prawnej oœwiadczam, ¿e niniejsza praca dyplomowa zosta³a napisana przeze mnie samodzielnie i nie zawiera treœci uzyskanych w sposób niezgodny z obowi¹zuj¹cymi przepisami. \\
Oœwiadczam równie¿, ¿e przedstawiona praca nie by³a wczeœniej przedmiotem procedur zwi¹zanych z uzyskaniem tytu³u zawodowego w wy¿szej uczelni.}
\\ \\
Kraków, dnia	\hfill{Podpis autora pracy}  \\ \\ \\ \\ \\ \\ \\ \\ \\



\huge {Oœwiadczenie kieruj¹cego prac¹} \\
\large {Potwierdzam, ¿e niniejsza praca zosta³a przygotowana pod moim kierunkiem i kwalifikuje siê do przedstawienia jej w postêpowaniu o nadanie tytu³u zawodowego.}
\\ \\
Kraków, dnia 	 \hfill {Podpis kieruj¹cego prac¹}
\vfill\pagebreak

% Spis treœci %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\renewcommand{\thesection}{\arabic{chapter}.\arabic{section}}
\tableofcontents % Spis treœci jest generowany automatycznie przez LaTeXa
\let\cleardoublepage\clearpage % To taka ma³a sztuczka, która nie pozwala LaTeXowi wstawiaæ pustych stron przed nowymi rozdzia³ami
%\pagestyle{myheadings} \markboth{}{} % Ta komenda pozwala pozbyæ siê nag³ówków stron

% Wstêp %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter*{Wstêp}

	Wybór tematu poni¿szej pracy jest uzasadniony zaintresowaniami autora w dziedzinie robotyki i elektroniki, jak równie¿
sugestiami osób promuj¹cych pracê oraz faktem, ¿e roboramiona s¹ powszechnie u¿ywane w projektach elektronicznych i maszynach przemys³owych. 
Podstaw¹ w poprawnym dzia³aniu takich ramion jest odpowiednie zaprojektowanie, ale ¿adna, nawet najbardziej dopracowana maszyna, mo¿e byæ bezu¿yteczna,
jeœli byt odpowiadaj¹cy za jej pracê jest nieprawid³owo przygotowany, dlatego bez odpowiedniego programu obs³uguj¹cego elektronikê ¿aden projekt nie ma sensu. \\
\indent
	Najbardziej popularniej i ogólnie dostêpne czêœci na rynku elektronicznym s¹ zazwyczaj
bardzo prymitywne w budowie, co oczywiœcie ma swoje zalety jak
i wady. Do tych drugich nale¿y awaryjnoœæ, ale nie spowodowana b³êdami projektowymi czy produkcyjnymi, a nieumiejêtnoœci¹ i brakiem rozwagi u¿ytkowników.
S¹ to uszkodzenia mechaniczne, polegaj¹ce na spaleniu czy po³amaniu mechanizmów wewnêtrznych, a powodem tego jest niedopasowanie tych elementów do 
warunków zewnêtrznych, w jakich bêd¹ one pracowaæ - nacisk elementów monta¿owych, zjawiska naturalne itd. Jednym z za³o¿eñ projektu i kolejnym aspektem 
motywuj¹cym do wykonania opisywanej pracy jest unikniêcie wy¿ej opisanej sytuacji. \\ \\
\indent
Kompletne Ÿród³a programów, napisane na potrzeby poni¿szej pracy, znajduj¹ siê pod adresem (I TU BÊDZIE LINK DO REPOZYTORIUM Z GITHUBA LUB INNY ZA£¥CZNIK) 
\\ \\
\indent
Autor pragnie zaprosiæ do czytania i refleksji nad opisywanymi problemami.

% G³ówna czêœæ pracy %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Ogólne przedstawienie problemu}
\section{Budowa ramienia robota - za³o¿enia}

W za³o¿eniach omawianego projektu budowane ramiê ma zostaæ wykorzystane do poruszania siê obiektu, czyli do bazy urz¹dzenia zostanie przymocowanych kilka sztuk prezentowanego ramienia oraz zostanie zaimplementowany algorytm synchronizuj¹cy ramiona. Projektowane ramiê mo¿na porównaæ do odnó¿a paj¹ka lub ludzkiej rêki bez d³oni - staw zawiasowy pozwalaj¹cy na ruch przymocowanego dystansu w jednej p³aszczyŸnie oraz staw kulisty pozwalaj¹cy na ruch ca³ej konstrukcji w dwóch p³aszczyznach. 
(tu model z CADa). \\
\indent
Kolejnym za³o¿eniem jest mo¿liwoœæ sterowania ramieniem za pomoc¹ aplikacji komputerowej wykorzystuj¹c 
wybrany kontroler HID (mysz lub joystick czêsto wykorzystywany w grach) oraz odpornoœæ na przeci¹¿enia
spowodowane napotkanymi przeszkodami.


\section{Dobór podzespo³ów i technologii}

Do budowy stawów, o których mowa w rodziale 1.1 wykorzystano serwa modelarskie SG90 - jedne 
z najbardziej popularnych i ³atwo dostêpnych serw na rynku, które charakteryzuj¹ siê równie¿
niskimi kosztami.  Poœrednikiem pomiêdzy serwami a komputerem, który zapewni odpowiedni¹ kontrolê serw 
oraz transmisjê szeregow¹ bêdzie p³ytka prototypowa Arduino Mega, oparta o mikrokontroler ATmega 2560
Charakteryzuje siê on zegarem o taktowaniu 16 MHz, 256 kB pamiêci Flash oraz 8kB pamiêci RAM. Ka¿da p³ytka z rodziny
Arduino posiada 10-cio bitowe przetworniki analogowo-cyfrowe, jednak tylko mikrokontroler w Arduino Mega posiada 
wbudowane wzmacniacze ró¿nicowe pozwalaj¹ce na ró¿nicowy pomiar napiêæ, co jest podstaw¹ uzyskania sygna³u zwrotnego
z serw i zabezpieczenia ich przed spaleniem. Opisywana p³ytka prototypowa posiada z³¹cze USB typu B, które pozwala na
pod³¹czenie jej do komputera w celu zaprogramowania oraz zapewnienia transmisji szeregowej, dziêki czemu mo¿emy w czasie 
rzeczywistym przesy³aæ instrukcje steruj¹ce z komputera oraz informacje o przeci¹¿eniach do komputera. \\ 
\indent
Za sterowanie serwami oraz analizê i prezentacjê informacji o przeci¹¿eniach odpowiada program komputerowy napisany
w jêzyku C\#. Jest to obiektowy jêzyk programowania zaprojektowany dla firmy Microsoft. Programy napisane w tym jêzyku s¹ 
kompilowane do jêzyka CIL (Common Intermediate Language) - jest to kod poœrednicz¹cy, który do wykonania wymaga œrodowiska 
uruchomieniowego np. .NET Framework. 

\begin{figure}[H]
	\centering
	\includegraphics[width=13cm]{../Grafiki/caly_uklad.png}
	\caption{Schemat opracowanego uk³adu umo¿liwiaj¹cego pomiary przeci¹¿eñ serwa}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=10cm]{../Grafiki/caly_schemat.png}
	\caption{Schemat blokowy prezentuj¹cy dzia³anie uk³adu}
\end{figure}


\chapter{Opis wybranych technologii}
\section{Czym s¹ serwa ? - zasada dzia³ania i ich specyfikacja }

Serwa, a w³aœciwie serwomechanizmy, s¹ podstawowymi elementami wykorzystywanymi w modelarstwie. 
Dziêki nim mo¿liwe s¹ ruchy ró¿nego typu czêœci sk³adowych modelu pozwalaj¹cych na sterowanie,
na przyk³ad serwa realizuj¹ wychylenia osi w modelach pojazdów, co umo¿liwia ich skrêcanie. 
Podstawowymi elementami, z których sk³ada siê serwo, s¹:
\begin{itemize}
	\item Silnik napêdowy sterowany pr¹dem sta³ym
	\item Potencjometr (do pomiaru po³o¿enia przek³adni)
	\item Wewnêtrzny uk³ad, który steruje prac¹ silnika
	\item Przek³adnia zêbata, pozwalaj¹ca uzyskaæ moment obrotowy 
\end{itemize}

Do sterowania serwami wykorzystywany jest sygna³ PWM (Pulse-Width Modulation) - jest to metoda regulacji 
pr¹du o sta³ej amplitudzie i czêstotliwoœci, natomiast zmianie ulega wype³nienie. Czêstotliwoœæ tego sygna³u 
w serwach analogowych, jakim jest SG90, to ok. 50 Hz. W serwach cyfrowych jest to 300 Hz i takie serwa maj¹ wiêksz¹ precyzjê.
Dziêki tranzystorom wbudowanym w mikrokontroler ATmega oraz funkcjom wbudowanym w Arduino wytworzenie takiego sygna³u
jest bardzo proste - inicjowany jest wartoœci¹ jednobajtow¹ czyli z zakresu 0-255 odpowiadaj¹ce brakowi i pe³nemu wype³nieniu (100\%) przebiegu. Wykorzystuj¹c podane wy¿ej dane
³atwo bêdzie zrozumieæ poni¿szy przyk³ad:
Przy czêstotliwoœci 50 Hz wykonywanych jest 50 zmian sygna³u w ci¹gu sekundy, czas trwania sygna³u po zmianie to
oko³o 20 ms. Sygna³ jest inicjowany wartoœci¹ 128 - oko³o po³owy z dostêpnego zakresu. W rezultacie na wyjœciu zostaje
otrzymany cykliczny sygna³, gdzie na przemian w odcinkach 20 ms wystêpuje 5 V i 0 V. Œrednio jest to odpowiednik 50\% dostêpnego zakresu napiêæ.
 
\begin{figure}[H]
	\centering
	\includegraphics[width=10cm]{../Grafiki/PWM.jpg}
	\caption{Wykres prezentuj¹cy sygna³ PWM - napiêcie od czasu }
\end{figure}
 

Dopiero w serwie, za pomoc¹ filtra dolnoprzepustowego, sygna³ ten jest uœredniany na napiêcie z zakresu 0-5V odpowiadaj¹ce procentowemu wype³nieniu przebiegu.

\begin{figure}[H]
	\centering
	\includegraphics[width=6cm]{../Grafiki/filtr_doln.png}
	\caption{Schemat filtra dolnoprzepustowego }
\end{figure}


\indent Do przek³adni przymocowany jest potencjometr, który obraca siê wraz z jej obrotem. Zmiana rezystancji
 jest informacj¹ o aktualnym po³o¿eniu serwa. W oparciu o dzielnik napiêcia powstaje sygna³ napiêciowy, który trafia do komparatora, gdzie jest porównywany z podanym
napiêciem wzorcowym (sygna³em steruj¹cym PWM). Wytworzony w komparatorze sygna³ to informacja o ró¿nicy pomiêdzy aktualn¹ pozycj¹
silnika, a pozycj¹ zadan¹. Ta informacja trafia do korektora, a jego zadaniem jest obrócenie silnika tak, aby zmniejszyæ
ró¿nicê w pozycjach, a¿ do uzykania po¿¹danego efektu.
\begin{figure}[H]
	\centering
	\includegraphics[width=13cm]{../Grafiki/BlokScheme.png}
	\caption{Schemat blokowy opisuj¹cy dzia³anie serwa}
\end{figure}

Serwomechanizmy dzielimy na grupy, a podzia³ ten jest realizowany ze wzglêdu na wagê oraz materia³y,
z których jest wykonane serwo. W opisywanym projekcie wykorzystywane serwa to SG90 firmy Tower Pro. 
Jest to serwo z grupy micro, czyli o wadze do 10 gram oraz o plastikowych przek³adniach zêbatych. 
Inne grupy serw to:
\begin{itemize}
	\item mini - o wadze oko³o 25 g oraz metalowych lub karbonowych przek³adniach, a tym samym generuj¹ce wiêkszy moment si³y
	\item standard - du¿e serwa o wadze oko³o 50 g, wystêpuj¹ w ró¿nych odmianach, s¹ bardzo silne

\end{itemize}

Dok³adna specyfikacja wykorzystywanego serwa Tower Pro SG90 :
\begin{itemize}
	\item Zasilanie: 4.8 V - 6.0 V
	\item Zakres ruchu: 180$^\circ$
	\item Grupa: micro
	\item Moment 1.8 kg * cm
	\item Prêdkoœæ 0.10 s /60st
	\item Rodzaj: analogowe
	\item Wymiary 22x12x27 mm (d³ x szer x wys)
	\item Masa: 9 g	
\end{itemize}


\begin{figure}[H]
	\centering
	\includegraphics[width=4cm]{../Grafiki/SG90.jpg}
	\caption{Serwo Tower Pro SG90}
\end{figure}


\section{Pomiar ró¿nicowy - na czym polega ? Przewaga nad innymi rozwi¹zaniami }

W rozdziale 2.1 zosta³a opisana zasada ustalania i zmian pozycji serwa, która polega na porównywaniu napiêæ. 
S¹ to napiêcia odpowiadaj¹ce pozycji serwa. Niestety samo to rozwi¹zanie ma pewn¹ wadê - jeœli serwo nie znajdzie siê na zadanej
pozycji korektor bêdzie usilnie chcia³ odpowiednio ustawiæ silnik. Takie dzia³anie bêdzie prowadziæ do spalenia silnika lub
uszkodzenia przek³adni zêbatych. Za³o¿eniem projektu jest unikniêcie takich sytuacji. Wybranym rozwi¹zaniem tego problemu
jest zastosowanie rezystora bocznikuj¹cego w obwodzie zasilania serwa oraz wykonywanie ró¿nicowego pomiaru napiêcia, które na nim panuje, a w konsekwencji monitorowanie poboru pr¹du przez serwo 

Ró¿nicowy pomiar napiêcia polega na pod³¹czeniu dwóch bezpoœrednich koñców badanego elementu do wzmacniacza operacyjnego,
a dopiero napiêcie wyjœciowe wzmacniacza trafia bezpoœrednio do przetwornika ADC (Analog-\(>\)Digital Converter).
\begin{figure}[H]
	\centering
	\includegraphics[width=7cm]{../Grafiki/compADC.png}
	\caption{Schemat po³¹cznia badanego elementu z przetwornikiem}
\end{figure}

	
Zalet¹ tego rozwi¹zania jest odpornoœæ na ewentualne szumy, poniewa¿ przewody po³¹czeniowe s¹ blisko siebie,
s¹ tej samej jakoœci i d³ugoœci, a wiêc posiadaj¹ ten sam opór oraz zewnêtrzne oddzia³ywania wp³ywaj¹ tak samo na oba przewody,
czyli ró¿nica napiêæ w nich panuj¹cych bêdzie taka sama niezale¿nie od zaburzeñ zewnêtrznych. 
\begin{figure}[H]
	\centering
	\includegraphics[width=12.5cm]{../Grafiki/DiffNoise.jpg}
	\caption{Wykres prezentuj¹cy wyniki pomiaru ró¿nicowego, kiedy wystêpuj¹ szumy}
\end{figure}


Innym mo¿liwym rozwi¹zaniem problemu jest rozebranie serwa i pod³¹czenie siê do sygna³u z potencjometru lub komparatora,
odpowiednia analiza w mikrokontrolerze i interakcja. Jednak w tym przypadku przeci¹¿enie mo¿na mierzyæ tylko na podstawie
pomiaru czasu w jakim serwo siê przemieszcza do zadanej pozycji, a logicznym jest, ¿e jeœli trwa to zbyt d³ugo to oznacza, ¿e 
silnik jest w jakiœ sposób blokowany. To rozwi¹zanie, z pozoru ³atwiejsze, ma jednak pewne wady - w pomiarze musi zostaæ
uwzglêdniona ustalona prêdkoœæ serwa, co dodatkowo skomplikuje algorytm. Serwa przemieszczaj¹ siê doœæ szybko, a przetworniki ADC
wbudowane w mikrokontroler maj¹ ograniczon¹ szybkoœæ, zw³aszcza kiedy ten sam mikrokontroler musi zapewniæ równie¿ transmisjê
szeregow¹ i sterowanie serwem. Ponadto w tym rozwi¹zaniu nie jest zapewniona odpornoœæ na szumy, dlatego wybrane do opisywanego 
projektu rozwi¹zanie polegaj¹ce na ró¿nicowym pomiarze napiêcia wydaje siê byæ jednym z najlepszych. \\


\section{Przygotowany rezystor bocznikuj¹cy - dobór parametrów czêœci }

Jak opisano w rodziale 2.2 pomiar ró¿nicowy wykonywany jest na elemencie elektronicznym - w tym przypadku jest to 
rezystor bocznikuj¹cy, czyli rezystor o bardzo ma³ej rezystancji i du¿ej precyzji przeznaczony do pomiaru du¿ych pr¹dów i nie 
wprowadzaj¹cy znacz¹cych strat w uk³adzie. Takie rezystory wykorzystywane s¹ we wszelkiego rodzaju miernikach natê¿enia. \cite{Elektronika}
Na potrzeby projektu powsta³a p³ytka z prostym uk³adem umo¿liwiaj¹cym opisywane pomiary. Zastosowano rezystor bocznikuj¹cy 
o oporze 0.1$\Omega$,
 który zosta³ pod³¹czony szeregowo z silnikiem. W trakcie wykonywania ruchów przez serwo,
napiêcie na rezystorze roœnie. Dodatkowo w uk³adzie zastosowano kondensatory 10 $\mu$F 63V pod³¹czone równolegle miêdzy napiêciem
a mas¹, aby zapewniæ odpornoœæ na szumy, iskrzenia silnika - silniki s¹ elementami indukcyjnymi

\begin{figure}[H]
	\centering
	\includegraphics[width=12cm]{../Grafiki/boardSchema.png}
	\caption{Schemat przygotowanego uk³adu umo¿liwiaj¹cego pomiary}
\end{figure}


\chapter{Program dla mikrokontrolera}
\section{Œrodowisko ARDUINO }


Arduino jest to elektroniczna platforma z otwartym Ÿród³em, która pozwala na proste programowanie wczeœniej 
przygotowanych mikrokontrolerów. Arduino udostêpnia interfejs programowy, który w intuicyjny sposób pozwala wykonywaæ z³o¿one 
opracje na rejestrach steruj¹cych ATmegi. Jest to projekt stale rozwijany, posiadaj¹cy wielu zwolenników, mnóstwo ksi¹¿ek do nauki
oraz niezliczon¹ iloœæ wci¹¿ powstaj¹cych modu³ów poszerzaj¹cych funkcjonalnoœæ p³ytek prototypowych. Na p³ytce znajduje
siê konwerter USB\(<->\)RS-232(o napiêciach TTL), a twórcy udostêpniaj¹ proste œrodowisko programistyczne z wbudowanym kompilatorem dziêki czemu 
szereg operacji wymaganych przy typowym programowaniu procesorów AVR sprowadza siê do napisania kodu, pod³¹czenia p³ytki
do portu USB i klikniêcia przycisku 'PROGRAMUJ'. \\
\indent Prostota obs³ugi i programowania wynika z wbudowanego bootloadera - programu ³aduj¹cego skompilowany kod u¿ytkownika do pamiêci FLASH mikrokontrolera \cite{Arduino}
\begin{figure}[H]
	\centering
	\includegraphics[width=5cm]{../Grafiki/arduino.png}
	\caption{Logo projektu ARDUINO}
\end{figure}


\section{ATmega 2560 - wzmacniacze ró¿nicowe }
Spoœród p³ytek z rodziny Arduino (m.in. Uno, Leonardo, Yum, Nano, Micro, Mega) tylko model Mega posiada mikrokontroler 
spe³niaj¹cy wymagania projektu. Jest to mikrokontroler ATmega 2650 posiadaj¹cy wzmacniacze ró¿nicowe.
Przetworniki ADC wbudowane w mikrokontroler s¹ 10-cio bitowe co oznacza, ¿e zakres otrzymywanych, zdigitalizowanych wartoœci napiêcia jest
z przedzia³u 0-1023, a mierzone napiêcie trafiaj¹ce do przetwornika mo¿e byæ z zakresu 0V - 5V, czyli uzyskany pomiar 
ma dok³adnoœæ 4.88mV, a w przypadku pomiaru ró¿nicowego jest to 9.17mV, poniewa¿ zakres wartoœci z prztwornika to 
[-512, +511]. 
Opór opisanego w rozdziale 2.3 rezystora bocznikuj¹cego jest bardzo ma³y, a to oznacza, ¿e spadek napiêcia mierzony na nim 
równie¿ jest niewielki, czyli rozbie¿noœæ wartoœci okreœlaj¹ca czy serwo jest w trakcie ruchu czy w spoczynku równie¿ 
jest niewielka i musi byæ wzmocniona tak, aby odpowiada³a zakresowi dynamicznemu przetwornika ADC. Tu z pomoc¹ przychodzi wspomniany wzmacniacz ró¿nicowy, który
dodatkowo ma mo¿liwoœæ wzmocnienia sygna³u  10 lub 200 razy co oznacza, ¿e powsta³a 
ró¿nica jest wzmacniania i dopiero ta wartoœæ trafia do 10-bitowego przetwornika. Dok³adnoœæ pomiaru, w przypadku 
wzmocnienia x200, wzrasta do 24 $\mu$V w przedziale 0-25 $mV$.  \\
\indent Przyk³ad wyliczenia $\Delta$U dla rezystancji opornika $R=0.1\Omega$ i pr¹du $I=0.005A$: \\
$\Delta U = R \cdot I = 0.1\Omega \cdot 0.05A = 0.005V = 5mV$ 

\begin{figure}[H]
	\centering
	\includegraphics[width=12cm]{../Grafiki/BezWzmocnienia.jpg}\\
\includegraphics[width=12cm]{../Grafiki/ZWzmocnieniem.jpg}
	\caption{Wykresy prezentuj¹ce si³ê sygna³u ze wzmocnieniem i bez}
\end{figure}


Wy¿ej opisana operacja powoduje diametralne zwiêkszenie rozbie¿noœci miêdzy wartoœciami pr¹dów w ró¿ncyh stanach
pracy serwomechanizmu. 

\section{Transmisja szeregowa ARDUINO \(<=>\) PC oraz przyjêty protokó³ danych }

Transmisja szeregowa polega na szeregowym wysy³aniu i odbieraniu symboli, czyli jeden po drugim. W Arduino odbywa siê 
to za pomoc¹ wbudowanego portu USB.  Zainicjowany w programie BaudRate 
(liczba symboli na sekundê) jest równa iloœci bitów przesy³anych na sekundê, poniewa¿ standard USB 2.0 pos³ugujê siê tylko 
dwoma stanami 0 i 1 dla odpowiednich napiêæ. Zosta³a ustawiona jedna z domyœlnych przepustowoœci i wynosi 57600 bps (bod per second). 

W celu zapewnienia porozumienia miêdzy urz¹dzeniami zosta³a opracowana pewna konwencja przesy³ania informacji. 
Przesy³ane i odbierane s¹ ci¹gi znaków, które kolejno s¹ analizowane przez programy na urz¹dzeniach. Informacje s¹ przesy³ane
tylko podczas wykonywania interakcji tak, aby nie zape³niæ buforów w p³ytce, poniewa¿ mikrokontroler  ma ograniczone zasoby. 
W momencie wyst¹pienia przeci¹¿enia Arduino wysy³a sekwencjê znaków:  $D_{n}:val $ , gdzie $n$ jest numerem serwa, a $val$ jest wartoœci¹
odczytan¹ za pomoc¹ ró¿nicowego pomiaru na tym w³aœnie serwie. Arduino odbiera równie¿ sygna³y steruj¹ce z komputera w postaci:
$S_{n}:pos$ ,  gdzie $n$ jest numerem wybranego serwa, a $pos$ jest pozycj¹ w jakiej serwo ma siê ustawiæ i ze wzglêdu na ograniczenia, 
w postaci plastikowych elementów monta¿owych wartoœæ ta jest z zakresu 10-140, które oznaczaj¹ k¹t w stopniach.

\section{Brak pomiaru ró¿nicowego w interfejsie programowym ARDUINO - dzia³ania na rejestrach mikrokontrolera }

W zwi¹zku z wystêpowaniem wzmacniaczy ró¿nicowych tylko w modelu Mega, Arduino nie udostêpnia w interfejsie funkcji do 
³atwego wykonywania takich pomiarów. Rozwi¹zaniem jest napisanie w³asnych funkcji, które bezpoœrednio ustawiaj¹ odpowiednie
bity w rejestrach mikrokontrolera, o których mo¿na przeczytaæ w dokumentacji ATmegi 2560 \cite{ATmega2560}. Nale¿y ustawiæ porty, do których 
pod³¹czone s¹ elementy wymagaj¹ce pomiaru, wartoœci referencyjne, z którymi sygna³ bêdzie porównywany - tu zosta³ ustawiony 
na port sygna³ z portu zewnêtrznego, do którego nic nie jest pod³¹czone.
Bity w opisywanych rejestrach s¹ te¿ zmieniane przez mikrokontroler, co na przyk³ad oznacza ukoñczony pomiar,
gotowy do odczytu. Zamieszczony ni¿ej fragment kodu zawiera funckje do inicjalizacji i wykonywania ró¿nicowych pomiarów napiêcia:
\begin{lstlisting}
void initdiff(){    // definition of initialization function
	ADCSRA=(1<<ADEN)|(1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0);
	ADMUX = (1<<REFS0) |(0<<REFS1);       // set reference voltage
	ADMUX |= (1<<MUX3)|(1<<MUX1)|(1<<MUX0);  // set  ports to read voltage (particular)
}
void adc1() {
	ADCSRB = (0<<MUX5);    // set read port on A0 and A1
}
void adc2() {
	ADCSRB = (1<<MUX5);    // set read port on A8 and A9  
}
uint16_t do_adc() {    // defintion of read function
	ADCSRA |= (1<<ADSC); //Start an ADC conversion by setting the ADSC bit.
	while(!(ADCSRA & (1<<ADIF)));  //Wait for the conversion to finish. The ADC signals that it's finished
	ADCSRA|=(1<<ADIF); 
	return ADC;  //Return the ADC result from the ADC register.
};
\end{lstlisting}

Ca³y kod dostêpny jest w repozytorium na platformie GitHub, do którego link podano na wstêpie pracy. 

\chapter{Aplikacja komputerowa GUI}
\section{Wybór jêzyka programowania }

Praktycznie ka¿dy z powszechnie znanych jêzyków oprogramowania udostêpnia biblioteki lub funkcje wbudowane pozwalaj¹ce na inicjowanie i komunikacjê
z urz¹dzeniami za pomoc¹ transmisji szeregowej z wykorzystaniem portu szeregowego (emulowanego przez sterownik FTDI). Mnóstwo jêzyków umo¿liwia te¿ proste przygotowanie graficznej reprezentacji danych, dlatego pojawia siê
oczywiste logiczne pytanie: Dlaczego .NET C\# ?

Sk³adnia programu pisanego w œrodowisku Arduino do z³udzenia przypomina sk³adniê C++ - jest to w³aœciwie C++ z dodanymi funkcjami do obs³ugi
mikrokontrolera - dlatego dla zachowania jednolitoœci i prostego zrozumienia kodu naturalnym by³oby wybranie C++ dla napisania aplikacji komputerowej.
Ponadto C\# posiada wiele wbudowanych modu³ów do transmisji szeregowej, rysowania wykresów i prostego tworzenia GUI, co znacznie u³atwia implementacjê \cite{Csharp}.
\begin{figure}[H]
	\centering
	\includegraphics[width=7cm]{../Grafiki/CsharpLogo.png}
	\caption{Logo Microsoft Visual C\#}
\end{figure}



\section{Struktury u¿yte w aplikacji oraz wykrywanie przeci¹¿eñ serwomechanizmów }

C\# jest jêzykiem wysokopoziomowym, obiektowym wiêc ka¿da u¿yta struktura jest klas¹ lub nale¿y do klasy. Napisany program komputerowy zbiera informacje 
o aktualnych przeci¹zeniach serw oraz poddaje je analizie. Otrzymane sygna³y s¹ czêsto skrajne - dla braku przeci¹¿eñ pojawiaj¹ce siê wartoœci poboru pr¹du s¹ mniejsze
od 10-ciu jednostek ADC, natomiast w momencie pojawienia siê samego ruchu serwa wartoœci te przekraczaj¹ 500 [a.u.]. Sposobem wykrycia przeszkody i blokady serwa, a nie samego ruchu, 
jest zebranie informacji z pewnego odcinka czasu i obliczenie krocz¹cej œredniej arytmetycznej odczytów, poniewa¿ po wykonaniu ruchu otrzymywane wartoœci ponownie malej¹. 
Do zmagazynowania informacji nadchodz¹cych z mikrokontrolera wykorzystano zmodyfikowan¹ kolejkê FIFO - domyœlna kolejka zaimlememntowana w C\# jest oparta o listê
wskaŸnikow¹, czyli teoretycznie o nieskoñczonej pojemnoœci i braku dostêpu do konkretnej liczby elemetnów wstecz. Spersonalizowana kolejka posiada konkretnie
zdefiniowan¹ wielkoœæ, co oznacza, ¿e w przypadku przepe³nienia kolejki kolejny element nie zostanie bezpoœrednio dodany - wczeœniej zostanie skasowany 
najstarszy element. Œredni¹ arytmetyczn¹ ostanich wartoœci mo¿na obliczyæ sumuj¹c wartoœci wszystkich przechowywanych elementów za pomoc¹ funckji $foreach$
oraz podzieliæ otrzyman¹ wartoœæ przez g³êbokoœæ zdefiniowanej kolejki. Wielkoœæ ta jest zale¿na od szybkoœci nap³ywania danych z mikrokontrolera oraz 
zamierzonej iloœci ostanich sekund, z których jest obliczana wspomniana œrednia.\\
\begin{lstlisting}
public float Average()   // calculate average based on all values in queue
{
	int sum = 0;
	foreach (int obj in myQ)
	sum += obj;
	return sum / size;
}

\end{lstlisting}

Jak opisano w rozdziale 3.3 informacje o przeci¹¿eniach s¹ wysy³ane tylko w momencie wystêpowania przeci¹¿eñ, czyli wysokich wartoœci napiêcia zmierzonego na boczniku, natomiast 
informacje do kolejki w aplikacji komputerowej musz¹ trafiaæ stale, dlatego mikrokontroler wysy³a te¿ jedn¹ nieprzeci¹¿on¹ wartoœæ, a w¹tek w programie
periodycznie kopiuje tê wartoœæ i wstawia do kolejki, a tym samym œrednia wartoœæ spada zgodnie z za³o¿eniem, nie nadu¿ywaj¹c buforów mikrokontrolera.\\


\section{Inicjalizacja po³¹czenia i sterowanie serwami - ci¹g dalszy przyjêtego protoko³u danych}

W programie wykorzystano domyœlny modu³ do komunikacji szeregowej. Funckje w nim zawarte pozwalaj¹ w ³atwy sposób otworzyæ port komunikacyjny, zainicjowaæ
po³¹czenie z odpowiednimi parametrami oraz odczytywaæ i wysy³aæ dane. Jako ¿e to aplikacja sprawdza wystêpowanie przeci¹¿eñ na serwach, nie mog¹
one zostaæ pod³¹czone przez uk³ad mikrokontrolera jeœli nie zostanie zainicjowanie po³¹czenie z programem na PC. Zosta³o to zrealizowane w nastêpuj¹cy sposób:
\begin{enumerate}[{1}]
	\item Mikrokontroler po uruchomieniu wysy³a periodycznie specjalne has³o $I am GOD$, które zosta³o podane w implementacji.
	\item To samo has³o zosta³o podane w kodzie programu komputerowego - program po otwarciu portu sprawdza, czy otrzymywane has³o zgadza siê z podanym w kodzie.
	\item Po zweryfikowaniu urz¹dzenia program wysy³a do mikrokontolera swój kod (ten sam), a mikrokontroler porównuje has³o wbudowane i otrzymane. 
	\item Po zweryfikowaniu kodu, mikrokontroler uruchamia sterowanie serwami.
\end{enumerate}


Po zamkniêciu aplikacji oraz wykryciu przeci¹¿enia program wysy³a do mikrokontrolera polecenie inicjuj¹ce od³¹czenie serw $exit$ oraz $break$, aby unikn¹æ ich zniszczenia.
Gdy œrednia pr¹dów mierzonych na boczniku spadnie poni¿ej pewnego, zadanego poziomu zostaje wys³ane polecenie $continue$, które wymusza ponowne pod³¹czenie serw. \\

\section{Prezentacja danych }

Aplikacja komputerowa zosta³a napisana wykorzystuj¹c œrodowisko Visual Studio 2015. Jedn¹ z klas wbudowanych w C\# oraz narzêdziem oferowanym 
w "Visualowym ToolBoxie" jest Chart, czyli z jêzyka angielskiego "Wykres". Udostêpnia on  intuicyjny interfejs, w którym wystarczy wybraæ typ wykresu,
typ linii ³¹cz¹cej punkty wykresu (np. spline), kolorystykê, legendê, a w trakcie dzia³ania programu dodawane s¹ wartoœci do aktualnego czasu i wpisywane w wykres. Dodatkowo za pomoc¹ 
wbudowanej w klasê funckji wykres jest przeskalowywany wzglêdem osi Y dla lepszej czytelnoœci w przypadku d³u¿szego pojawiania siê podobnych wartoœci. 
(wykresy z programu)

Interwa³ czasowy z jakim wprowadzane s¹ dane do wykresu musi byæ równy interwa³owi z jakim przychodz¹ dane z mikrokontrolera, 
a w³aœciwie z jakim dane wp³ywaj¹ do kolejki opisanej w rozdziale 5.2 tak, aby wprowadzane wartoœci nie dublowa³y siê oraz nie zosta³y pominiête.
(byæ mo¿e fragment kodu)\\

\section{Wykorzystanie kontrolera gier do sterowania ramieniem  }

Do aplikacji zaimplementowano dodatkow¹ funckjonalnoœæ jak¹ jest mo¿liwoœæ sterowania ramieniem robota za pomoc¹ kontrolera do gier.
W tym celu wykorzystano otwartoŸród³owe API (Application Programming Interface) do DirectX o nazwie SlimDX, które jest przeznaczone g³ównie do tworzenia gier 
pod platform¹ .NET, ale w tym przypadku pos³u¿y³o do oprogramowania kontrolerów do gier. Interfejs, który udostêpnia SlimDX, jest uniwersalny i implementacja
jednego kodu pozwala na u¿ywanie ró¿nego typu kontrolerów do gier - joysticków, gamepadów, kierownic itd. Do u¿ycia wystarczy zaledwie pod³¹czyæ kontroler
do komputera wraz z zainstalowanymi sterownikami do urz¹dzenia, uruchomiæ aplikacjê i spoœród listy dostêpnych urz¹dzeñ wybraæ to interesuj¹ce. 
(screen z aplikacji z podkreœlniem opcji wyboru)
(tu byæ mo¿e oopiszê mój kontroler z ma³¹ instrukcj¹ obs³ugi)

\chapter{Podsumowanie oraz przyk³ady wykorzystania projektu}

Realizacja opisywanego projektu przebieg³a pomyœlnie - opracowano uk³ad i algorytm pozwalaj¹cy na odpowiednie sterowanie ramieniem robota zabezpieczaj¹c przy tym serwa przed przeci¹¿eniami. 
Program alarmuje u¿ytkownika o zaistnia³ych, groŸnych przeci¹¿eniach - s¹ one rozró¿niane od przeci¹¿eñ powstaj¹cych przy zmianie pozycji serwa.

\begin{figure}[H]
	\centering
	\includegraphics[width=10cm]{../Grafiki/podsumowanie.png}
	\caption{Wykresu prezentuj¹ce pozycjê serwa i wystêpuj¹ce przeci¹¿enia w czasie}
\end{figure}

Technologiê wykrywania przeci¹¿eñ opisan¹ w powy¿szej pracy, przy odpowiednim doborze parametrów czêœci elektronicznych, mo¿na zastosowaæ niemal w ka¿dym
urz¹dzeniu wymagaj¹cym takiej kontroli, dlatego iloœæ zastosowañ jest praktycznie nieskoñczona. Mog¹ to byæ nie tylko serwa, ale równie¿ standardowe silniki,
si³owniki, pompy itp. Do najbardziej oczywistych zastosowañ prezentowanego projektu nale¿y system poruszania siê i przesuwania przeszkód w eksploratorach
obszarów czy ³azikach pozaziemskich - poruszanie siê na np. szeœciu koñczynach podobnych do  pajêczych jest du¿o bardziej odporne na utrudnienia terenu, ni¿
ko³a czy g¹sienice. 

\begin{figure}[H]
	\centering
	\includegraphics[width=7cm]{../Grafiki/robo_spider.png}
	\caption{Przyk³adowy model robota, w którym mo¿na zastosowaæ serwa z pomiarem przeci¹¿eñ}
\end{figure}

Innym przyk³adem s¹ modele samolotów, w których uk³ad sterowania lotek czêsto realizowany jest za pomoc¹ serwomechanizmów. Silne opory powietrza mog¹ zniszczyæ
mechanizm, a wiêc za pomoc¹ systemu u¿ytkownik dostanie ostrze¿enie o takiej mo¿liwoœci i sugestiê zaprzestania lotów.
\begin{center}

\end{center}
\begin{figure}[H]
	\centering
	\includegraphics[width=7cm]{../Grafiki/RC_Plane.jpg}
	\caption{Model samolotu, wymagaj¹cego serw do sterowania}
\end{figure}

Prototypy linii monta¿owych w fabrykach, a w³aœciwie ramion pracuj¹cych na linii to równie¿ przyk³ad, w którym wymagane jest kontrolowanie znacz¹cej liczby serw
i silników. W przypadku awarii firma poniesie ogromne straty produkcyjne, jak równie¿ ucierpieæ mog¹ pracownicy obs³uguj¹cy maszyny - odpowiedni system mo¿e 
temu przeciwdzia³aæ. Identyczna sytuacja jak i konsekwencje mog¹ siê pojawiæ w przypadku braku kontroli "³y¿ek" w koparkach. \\
W pracy wykorzystano informacje i wiedzê z zakresu:

\begin{itemize}
	\item \textbf{elektroniki} (pomiar natê¿enia pr¹du z u¿yciem bocznika, pomiar ró¿nicowy, przetwarzanie ADC)
	\item \textbf{programowania mikrokontrolerów} (dog³êbne poznanie funkcji ADC w ATmegach, transmisja szeregowa danych z potwierdzeniem, protoko³y danych)
	\item \textbf{programowania GUI} (C\#, œrednie krocz¹ce, HIDy, grafika, obs³uga portów szeregowych)
	\item \textbf{mechaniki} (budowa serwomechanizmów, ramion robota itp.)
\end{itemize}


\begin{thebibliography}{10}

\bibitem{Elektronika} B.M. Oliver, J.M. Cage, {\it Pomiary i przyrz¹dy elektroniczne}, Wydawnictwa Komunikacji i £¹cznoœci, Warszawa 1978 

\bibitem{Arduino} https://www.arduino.cc/

\bibitem{ATmega2560} {\it Atmel ATmega640/V-1280/V-1281/V-2560/V-2561/V DATASHEET},
\\Atmel Corporation, 2014

\bibitem{Csharp} I. Griffiths, M. Adams, J. Liberty, {\it C\#. Programowanie. Wydanie VI}, Helion, 2012 % Universitext to nazwa serii wydawniczej. Jeœli
% ksi¹¿ka nie by³a wydana w ramach serii to to pole siê pomija.






\end{thebibliography}

\end{document}